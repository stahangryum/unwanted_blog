{
  
    
        "post0": {
            "title": "데이터 타입",
            "content": "&#45936;&#51060;&#53552; &#53440;&#51077; . &#49688;&#52824;&#54805;(numeric) . 정수, 실수, 지수 등을 나타내며 실수가 기본형 | . a=345 mode(a) . [1] &#34;numeric&#34; . a=34.5556 mode(a) . [1] &#34;numeric&#34; . &#45436;&#47532;&#54805;(logical) . 참(TRUE)과 거짓(FALSE)를 나타낸다. | . A = TRUE mode(A) . [1] &#34;logical&#34; . A = F mode(A) . [1] &#34;logical&#34; . A = T mode(A) . [1] &#34;logical&#34; . &#47928;&#51088;&#54805;(character) . A = &quot;friendship&quot; mode(A) . [1] &#34;character&#34; . A = &quot;TRUE&quot; mode(A) . [1] &#34;character&#34; . A = &quot;1&quot; mode(A) . [1] &#34;character&#34; . &#48373;&#49548;&#49688;&#54805;(complex) . a = 1+3i b = 3+7i a+b . [1] 4+10i . mode(a) . [1] &#34;complex&#34; . mode(a+b) . [1] &#34;complex&#34; . &#51221;&#49688;&#54805;(integer) . 생략 | . &#45936;&#51060;&#53552; &#53440;&#51077; &#48320;&#54872; . &#52395; &#48264;&#51704; &#48169;&#48277; . a = &quot;1&quot; mode(a) . [1] &#34;character&#34; . mode(a) &lt;- &quot;numeric&quot; mode(a) . [1] &#34;numeric&#34; . a . [1] 1 . &#46160; &#48264;&#51704; &#48169;&#48277; . a = T as.numeric(a) . [1] 1 . a = F as.numeric(a) . [1] 0 . a = -1 as.logical(a) . [1] TRUE . a = 2 as.logical(a) . [1] TRUE . a = 2.22 as.logical(a) . [1] TRUE . a = 0 as.logical(a) . [1] FALSE . 강제형변환 | . a = &quot;asdfasfasf&quot; a = as.numeric(a) . Warning message in eval(expr, envir, enclos): &#34;강제형변환에 의해 생성된 NA 입니다&#34; . mode(a) . [1] &#34;numeric&#34; . as.logical(a) . [1] NA . a = as.logical(a) mode(a) . [1] &#34;logical&#34; . as.character(a) . [1] NA . &#49436;&#47196; &#45796;&#47480; &#54805;&#51004;&#47196; &#51060;&#47336;&#50612;&#51652; &#48289;&#53552;&#51032; mode . 문자형 섞여있으면 모두 문자형으로 바뀐다. | . a &lt;- c(1, T, &quot;1&quot;) a . [1] &#34;1&#34; &#34;TRUE&#34; &#34;1&#34; . mode(a) . [1] &#34;numeric&#34; . 문자형이 없으면 모두 numeric형으로 바뀐다. | . a &lt;- c(1, T) a . [1] 1 1 . mode(a) . [1] &#34;numeric&#34; . 서로 다른 형을 가진 벡터를 만들면 한가지 형으로 자동 형 변환이 된다. | . mode가 두 개일 수 없다. | . &#44284;&#51228; . A = matrix(1:9, ncol=3, byrow=TRUE) A . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . B = (-A) B[3,3] = -10 B . [,1] [,2] [,3] [1,] -1 -2 -3 [2,] -4 -5 -6 [3,] -7 -8 -10 . A + B . [,1] [,2] [,3] [1,] 0 0 0 [2,] 0 0 0 [3,] 0 0 -1 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/11/03/R%EC%9E%85%EB%AC%B8-8%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/11/03/R%EC%9E%85%EB%AC%B8-8%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Nov 3, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "서술형",
            "content": "1번 문항 | . 다음 급수의 수렴 반지름과 수렴 구간을 구하라. . $ sum_{n=1}^ infty dfrac{2^n(x-3)^n}{ sqrt{n+3}} $ . 2번 문항 | . 다음 곡선의 $t = dfrac{ pi}{4}$일 때, 접선의 방정식을 구하라. . $ x= sec ,t, y = tan ,t : - dfrac{ pi}{2} ,&lt; ,t ,&lt; dfrac{ pi}{2}$ . 3번 문항 | . $x = a ,cos ,t, y = a ,sin ,t$일 때, $ dfrac{d^2y}{dx^2}$을 구하여라. . 4번 문항 | . 다음 보기 중 참인 보기를 모두 고르시오. . (1) p-급수 $ sum_{n=1}^{ infty} dfrac{1}{n^P}$는 $p&gt;1$이면 발산이다. . (2) 사이클로이드는 직선 위를 따라 원이 구를 때, 원주 위의 점 P에 의하여 그려지는 곡선을 의미한다. . (3) $lim_{n to infty} |a_n|$이면 $lim_{n to infty}a_n =0$이다. . (4) $0 leq a_n leq b_n$이고, $ sum_{n=1}^{ infty}b_n$이 발산한다면, $ sum_{n=1}^{ infty}a_n$은 발산한다. . (5) $ lim_{n= infty}a_n$이 존재하지 않거나, $ lim_{n= infty}a_n neq 0$이면 $ sum_{n=1}^{ infty}a_n$은 발산한다. . 5번 문항 | . 급수의 수렴, 발산 판정법이 바르지 않은 것을 모두 찾아라. . (1) $ sum_{n=1}^{ infty} dfrac{(2n+1)^n}{n^{2n}}$ : 근판정법 . (2) $ sum_{n=1}^{ infty}(-1)^n dfrac{n}{n^2+2}$ : 교대급수판정법 . (3) $ sum_{n=1}^{ infty} dfrac{3^n n^2}{n!}$ : 발산판정법 . (4) $ sum_{n=1}^{ infty} dfrac{1}{n+3^n}$ : 비교판정법 . (5) $ sum_{n=1}^{ infty} dfrac{1}{2n+1}$ : 비판정법(비율판정법) . 6번 문항 | . 곡선 $x = 1+e^t, , y=t-t^2$과 $x$축으로 둘러싸인 넓이를 찾아라. . $x geq2$에서 연속이고 감소인 함수 $f(x) = dfrac{ln ,x}{x^3} &gt; 0$와 적분판정법을 이용하여, 다음 급수 $ sum_{n=1}^{ infty} dfrac{ln ,n}{n^3}$의 수렴여부를 판정하라. | 멱급수를 이용하여 $ int dfrac{x-tan^{-1}x}{x^3}dx$의 값을 구하라. 그리고 수렴반지름을 찾아라. | 매개변수방정식 $x=2cos^2 theta, y=sin2 theta$의 접선이 수평이 되는 점과 수직이 되는 점을 찾아라. | 문제1 : 비율판정법을 사용하면 . $lim_{n to infty}| dfrac{a_{n+1}}{a_n} = |2x-6| &lt; 1$이면 수렴한다. . 따라서 수렴 반지름 $R = dfrac{1}{2}$이다. 끝점은 별도로 판단하라. . 문제2 : $ dfrac{ dfrac{dy}{dt}}{ dfrac{dx}{dt}} = dfrac{dy}{dx},$ . $(sec ,t)&#39; = sec ,t ,tan ,t, (tan ,t)&#39; = sec^2t$ 임을 활용하라. .",
            "url": "https://stahangryum.github.io/stahangryum/2021/11/02/Untitled1.html",
            "relUrl": "/2021/11/02/Untitled1.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "R입문 중간고사 대비문제",
            "content": "#. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. . $2^{-5}+2^{3}$ | . 2^(-5) + 2^3 . 8.03125 $ sqrt{33}$ | . sqrt(33) . 5.74456264653803 $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ | . summ = 0 for (k in 1:100){ summ = summ + 1/(k^2 +2*k +1) } print(summ) . [1] 0.6350819 . ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#47564;&#46308;&#50612;&#46972;. . $(1,3,5,...,101)$ | . (0:50)*2 + 1 . &lt;ol class=list-inline&gt;1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 | 25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 | 41 | 43 | 45 | 47 | 49 | 51 | 53 | 55 | 57 | 59 | 61 | 63 | 65 | 67 | 69 | 71 | 73 | 75 | 77 | 79 | 81 | 83 | 85 | 87 | 89 | 91 | 93 | 95 | 97 | 99 | 101 | &lt;/ol&gt; ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#54632;&#49688;&#47484; &#49440;&#50616;&#54616;&#46972;. $x=1,2,3$ &#50640; &#45824;&#54616;&#50668; &#51452;&#50612;&#51652; &#54632;&#49688;&#51032; &#44208;&#44284;&#44050;&#51012; &#52636;&#47141;&#54616;&#46972;. . $f(x)=x^2$ | . f_x = function(x){ return (x^2) } print(f_x(1)) print(f_x(2)) print(f_x(3)) . [1] 1 [1] 4 [1] 9 . #. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? . (a) $e^x= sum_{n=0}^{ infty} frac{x^n}{n!}$ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (c) $e^x= 1-(x-1)+(x-1)^2-(x-1)^3+ dots $ . f_o &lt;- function(x){ return(exp(x)) } f_o(5) f_a &lt;- function(x, k){ summ = 0 for (i in 0:k){ summ = summ + (x^i)/factorial(i) } return(summ) } f_a(5, 100) #f_a와 f_o의 함숫값이 같다. x^k항이 커질수록 근사 정도가 좋다. . 148.413159102577 148.413159102577 f_b &lt;- function(x, k){ summ = 0 for (i in 0:k){ summ = summ + x^i } return(summ) } f_b(2,100) f_o(2) #f_b와 f_o의 함숫값이 현저하게 다르므로 같다고 보기 어렵다. . 2.53530120045646e+30 7.38905609893065 f_c &lt;- function(x, k){ summ = 0 for (i in 0:k){ summ = summ + ( (-1)^i * (x-1)^i ) } return(summ) } f_c(2,100) f_o(2) #f_c와 f_o의 함숫값이 현저하게 다르므로 같다고 보기 어렵다. . 1 7.38905609893065 $lim_{x to infty}e^x = infty$ . $lim_{x to infty}1-(x-1)+(x-1)^2-(x-1)^3 + dots neq infty$ . $ ,so , e^x neq 1-(x-1)+(x-1)^2-(x-1)^3 + dots$ . f&lt;-function(x, n){ a = c() a[1] = x for (i in 2:n){ a[i] = a[i-1] * x / n } print(sum(a) + 1) } f(3, 10) . [1] 5.285689 . g &lt;- function(x . (풀이) . f&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x/n sum(a)+1 } . g&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x sum(a)+1 } . h&lt;-function(x,N){ a&lt;-c() a[1]= -(x-1) for(n in 2:N) a[n]=a[n-1]*(1-x) sum(a)+1 } . x=2 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 0.1223894 -55.6109439 7.3890561 [1] 0.03350054 -119.61094390 6.38905610 [1] 8.103718e-03 -2.476109e+02 7.389056e+00 [1] 1.754512e-03 -5.036109e+02 6.389056e+00 [1] 3.435769e-04 -1.015611e+03 7.389056e+00 [1] 6.138994e-05 -2.039611e+03 6.389056e+00 [1] 1.008322e-05 -4.087611e+03 7.389056e+00 [1] 1.532098e-06 -8.183611e+03 6.389056e+00 [1] 2.165414e-07 -1.637561e+04 7.389056e+00 [1] 2.860474e-08 -3.275961e+04 6.389056e+00 [1] 3.546512e-09 -6.552761e+04 7.389056e+00 [1] 4.142349e-10 -1.310636e+05 6.389056e+00 [1] 4.573142e-11 -2.621356e+05 7.389056e+00 [1] 4.786394e-12 -5.242796e+05 6.389056e+00 [1] 4.760636e-13 -1.048568e+06 7.389056e+00 [1] 4.529710e-14 -2.097144e+06 6.389056e+00 . $x=2$일때: $k$가 커질수록 $exp(x) approx f(x,k)$ 이지만 다른것은 그렇지 않음 | . x=3 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 1.685537 -343.914463 41.085537 [1] 0.6730369 -1072.9144631 -22.9144631 [1] 0.2391084 -3259.9144631 105.0855369 [1] 7.638514e-02 -9.820914e+03 -1.509145e+02 [1] 2.214407e-02 -2.950391e+04 3.610855e+02 [1] 5.871745e-03 -8.855291e+04 -6.629145e+02 [1] 1.433839e-03 -2.656999e+05 1.385086e+03 [1] 3.243623e-04 -7.971409e+05 -2.710914e+03 [1] 6.832928e-05 -2.391464e+06 5.481086e+03 [1] 1.346506e-05 -7.174433e+06 -1.090291e+04 [1] 2.492217e-06 -2.152334e+07 2.186509e+04 [1] 4.348086e-07 -6.457006e+07 -4.367091e+04 [1] 7.173653e-08 -1.937102e+08 8.740109e+04 [1] 1.122453e-08 -5.811307e+08 -1.747429e+05 [1] 1.669996e-09 -1.743392e+09 3.495451e+05 [1] 2.368168e-10 -5.230177e+09 -6.990309e+05 . x=10 for (k in 5:50) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 20548.80 -89084.53 75170.47 [1] 19159.91 -1089084.53 -456270.53 [1] 17175.78 -11089084.53 4326698.47 [1] 14695.62 -111089084.53 -38720022.53 [1] 1.193989e+04 -1.111089e+09 3.487005e+08 [1] 9.184161e+03 -1.111109e+10 -3.138084e+09 [1] 6.678950e+03 -1.111111e+11 2.824298e+10 [1] 4.591274e+03 -1.111111e+12 -2.541866e+11 [1] 2.985370e+03 -1.111111e+13 2.287679e+12 [1] 1.838295e+03 -1.111111e+14 -2.058911e+13 [1] 1.073579e+03 -1.111111e+15 1.853020e+14 [1] 5.956311e+02 -1.111111e+16 -1.667718e+15 [1] 3.144854e+02 -1.111111e+17 1.500946e+16 [1] 1.582933e+02 -1.111111e+18 -1.350852e+17 [1] 7.608695e+01 -1.111111e+19 1.215767e+18 [1] 3.498377e+01 -1.111111e+20 -1.094190e+19 [1] 1.541083e+01 -1.111111e+21 9.847709e+19 [1] 6.514037e+00 -1.111111e+22 -8.862938e+20 [1] 2.645867e+00 -1.111111e+23 7.976644e+21 [1] 1.034129e+00 -1.111111e+24 -7.178980e+22 [1] 3.894339e-01 -1.111111e+25 6.461082e+23 [1] 1.414743e-01 -1.111111e+26 -5.814974e+24 [1] 4.963739e-02 -1.111111e+27 5.233476e+25 [1] 1.683850e-02 -1.111111e+28 -4.710129e+26 [1] 5.528535e-03 -1.111111e+29 4.239116e+27 [1] 1.758548e-03 -1.111111e+30 -3.815204e+28 [1] 5.424228e-04 -1.111111e+31 3.433684e+29 [1] 1.623837e-04 -1.111111e+32 -3.090315e+30 [1] 4.722033e-05 -1.111111e+33 2.781284e+31 [1] 1.334876e-05 -1.111111e+34 -2.503156e+32 [1] 3.671161e-06 -1.111111e+35 2.252840e+33 [1] 9.829419e-07 -1.111111e+36 -2.027556e+34 [1] 2.563938e-07 -1.111111e+37 1.824800e+35 [1] 6.519986e-08 -1.111111e+38 -1.642320e+36 [1] 1.617445e-08 -1.111111e+39 1.478088e+37 [1] 3.918103e-09 -1.111111e+40 -1.330279e+38 [1] 9.276846e-10 -1.111111e+41 1.197252e+39 [1] 2.182787e-10 -1.111111e+42 -1.077526e+40 [1] 5.093170e-11 -1.111111e+43 9.697737e+40 [1] 1.455192e-11 -1.111111e+44 -8.727964e+41 [1] 3.637979e-12 -1.111111e+45 7.855167e+42 [1] 3.637979e-12 -1.111111e+46 -7.069650e+43 [1] 3.637979e-12 -1.111111e+47 6.362685e+44 [1] 3.637979e-12 -1.111111e+48 -5.726417e+45 [1] 3.637979e-12 -1.111111e+49 5.153775e+46 [1] 3.637979e-12 -1.111111e+50 -4.638398e+47 . 답: (a) . #. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 2/3로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . #. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. . _a는 변수이름으로 가능하다. | . ... | . # &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. . 두점 $(1,2)$, $(1.1,2.1)$를 붉은 점으로 각각 시각화 하라. . | 동일한 플랏에 $(-1,-2)$, $(-1.1,-2.1)$을 푸른점으로 각각 시각화 하라. . | . 출력예시 . # &#48380;&#47553;&#44277;&#51032; &#49440;&#53469; . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . - 입력예시 . 입력 5 3 1 3 2 3 2 출력 8 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/11/02/(A3)-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "relUrl": "/introduction%20to%20r/2021/11/02/(A3)-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "볼링공 고르기",
            "content": "&#48380;&#47553;&#44277; &#44256;&#47476;&#44592; . Problem . A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N 개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. . 또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. . 예를 들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1, 3, 2, 3, 2일 때 각 공의 번호가 차레대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 3번), (2번, 5번), (3번, 4번), (4번, 5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . Example . 입력 예시 | . 입력 5 3 1 3 2 3 2 출력 8 . Solution I . N = 5 M = 3 a = c(1,3,2,3,2) count = 0 for (i in 1:length(a)){ for(j in 1:length(a)){ if ((a[i] != a[j]) &amp; (j &gt; i)) count = count + 1 } } count . [1] 8 . Solution II . ((a[i] != a[j]) &amp; (j &gt; i))에서 (j &gt; i)는 for문 선언부에서 처리할 수 있다. | . N = 5 M = 3 a = c(1,3,2,3,2) count = 0 for (i in 1:length(a)){ for(j in i:length(a)){ if (a[i] != a[j]) count = count + 1 } } count . [1] 8 . Solution III . 매트릭스를 이용하여 푼다. | . a = c(1,3,2,3,2) A = rep(0, 25*2) dim(A) = c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,] &lt;- c(a[i], a[j]) k = k + 1 } } vec1 &lt;- c() #무게가 같은 것을 뽑으면 FALSE for (i in 1:25){ vec1[i] = A[i,1] != A[i,2] } k=1 vec2 &lt;- c() #중복되는 것을 뽑으면 FALSE for (i in 1:5){ for (j in 1:5){ vec2[k] = (j&gt;i) k=k+1 } } sum(vec1&amp;vec2) #모두 TRUE인 것의 개수 . [1] 8 . Solution IV . Solution III의 간단한 형태. | . a = c(1,3,2,3,2) A = rep(0, 25*2) dim(A) = c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,] &lt;- c(a[i], a[j]) k = k + 1 } } vec1 &lt;- c() vec2 &lt;- c() for (i in 1:25){ vec1[i] &lt;- (A[i, 1] != A[i, 2]) vec2[i] &lt;- (A[i, 1] &gt; A[i, 2]) } sum(vec1&amp;vec2) . [1] 8 . Solution V . a = c(1,3,2,3,2) A = rep(0, 25*2) dim(A) = c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,] &lt;- c(a[i], a[j]) k = k + 1 } } vec1 &lt;- (A[,1] != A[,2]) vec2 &lt;- (A[,1] &gt; A[,2]) sum(vec1&amp;vec2 ) . [1] 8 . Solution VI . 생각해보니 단순히 첫번째 열이 두번째 열보다 큰지만 체크해도 된다. | . a = c(1,3,2,3,2) A = rep(0, 25*2) dim(A) = c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,] &lt;- c(a[i], a[j]) k = k + 1 } } sum( A[,1] &lt; A[,2] ) . [1] 8 . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . &#51648;&#44552;&#44620;&#51648; &#54400;&#51060; &#51221;&#47532; . 풀이 1 ~ 2 : 매트릭스를 사용하지 않음. . 풀이 3 ~ 6 : 매트릭스를 사용함. . 현재까지는 풀이2가 가장 간결하고 루프도 적게 돌아간다. 그러나 풀이 1 ~ 2는 수정 및 디버깅이 어렵다, -&gt; 예외사항을 처리하기 어려움. . 풀이 3 ~ 6은 루프가 많이 돌아가지만 수정 및 디버깅이 쉽다. . Solution VII - Data Frame . 사실 R에는 A를 바로 구하는 함수가 존재한다. | . expand.grid($x_1 dots x_2$): 벡터를 입력으로 받아서 그 벡터의 원소가 만들어내는 순서쌍 조합을 데이터프레임 형태로 리턴한다. | . mutate(): 데이터프레임에서 새로운 column를 추가하는 기능 (기존의 column을 활용하여 만들 수도 있다.) | . filter(): 데이터프레임에서 특정조건을 만족하는 행을 필터링 하는 기능 | . count(): 데이터프레임의 행의 숫자를 세어주는 기능 | . as.numeric(): numeric type(숫자형)으로 변경하는 기능 | . a = c(1,3,2,3,2) A = expand.grid(a, a) A . Var1 Var2 1 1 1 2 3 1 3 2 1 4 3 1 5 2 1 6 1 3 7 3 3 8 2 3 9 3 3 10 2 3 11 1 2 12 3 2 13 2 2 14 3 2 15 2 2 16 1 3 17 3 3 18 2 3 19 3 3 20 2 3 21 1 2 22 3 2 23 2 2 24 3 2 25 2 2 . library(tidyverse) . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C==TRUE) %&gt;% count -&gt; result . result . n 1 8 . 데이터프레임 형식으로 나오니 상수로 바꿔주자. . as.numeric(result) . [1] 8 . &#44284;&#51228; . A %&gt;% mutate(C= Var1 - Var2 &gt; 0) %&gt;% filter(C==TRUE) %&gt;% count %&gt;% as.numeric() . [1] 8 . Solution VIII . %*% 연산자 : 행렬의 곱셈 . | a %in% c(4, 9) : a의 모든 원소를 조사하고 그 원소가 4 또는 9 이면 TRUE, 그렇지 않으면 FALSE . | . a &lt;- c(1,3,2,3,2) a1 &lt;- a -&gt; a2 dim(a1) &lt;- c(5,1) #A dim(a2) &lt;- c(1,5) #A^T A = a1 %*% a2 A #대칭행렬이다. . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . . upper.tri() | . upper.tri(A) . [,1] [,2] [,3] [,4] [,5] [1,] FALSE TRUE TRUE TRUE TRUE [2,] FALSE FALSE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE [4,] FALSE FALSE FALSE FALSE TRUE [5,] FALSE FALSE FALSE FALSE FALSE . sum(!A[upper.tri(A)] %in% c(4, 9)) . [1] 8 . Solution IX . a &lt;- c(1,3,2,3,2) A = outer(a, a) A . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . sum(!A[upper.tri(A)] %in% c(4,9)) . [1] 8 . &#51648;&#44552;&#44620;&#51648; &#54400;&#51060; &#51221;&#47532; . 풀이 7 : 데이터프레임 활용 $ to$ 사용하기 쉽고 확장성이 좋다. . 풀이 8, 9 : 코드가 간결함 / 오류가 발생할 수 있음 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/27/R%EC%9E%85%EB%AC%B8-7%EC%A3%BC%EC%B0%A8-2%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/27/R%EC%9E%85%EB%AC%B8-7%EC%A3%BC%EC%B0%A8-2%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 27, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "R : matrix",
            "content": "&#47588;&#53944;&#47533;&#49828;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . &#48169;&#48277;1 : row-vector -&gt; rbind . rbind(c(1,2,3,4),c(2,3,4,5)) . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 3 4 5 . &#48169;&#48277;2 : column-vector -&gt; cbind . cbind(c(1,2,3,4),c(2,3,4,5)) . [,1] [,2] [1,] 1 2 [2,] 2 3 [3,] 3 4 [4,] 4 5 . &#47588;&#53944;&#47533;&#49828;&#51032; &#52264;&#50896;(dimension) . A = rbind(c(1,2,3,4),c(2,3,4,5)) dim(A) . [1] 2 4 . B = cbind(c(1,2,3,4),c(2,3,4,5)) dim(B) . [1] 4 2 . 차원을 바꿀 수도 있다. | . B . [,1] [,2] [1,] 1 2 [2,] 2 3 [3,] 3 4 [4,] 4 5 . dim(B) = c(2,4) . B . [,1] [,2] [,3] [,4] [1,] 1 3 2 4 [2,] 2 4 3 5 . &#47588;&#53944;&#47533;&#49828;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . A = rbind(c(1,2,3,4),c(5,6,7,8),c(9,10,11,12)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . A[1,] # 1행을 뽑고싶다. . [1] 1 2 3 4 . A[,1] # 1열을 뽑고싶다. . [1] 1 5 9 . A[, c(1,4)] # 1열, 4열을 뽑고싶다. . [,1] [,2] [1,] 1 4 [2,] 5 8 [3,] 9 12 . A[c(1,2),] # 1행, 2행을 뽑고싶다. . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 . A[2,3] # 2행3열의 원소를 뽑고싶다. . [1] 7 . apply &#54632;&#49688; . apply(matrix, 1, 특정함수) . 를 쓰면 어떠한 특정한수가 각각의 row에 적용되어서 결과가 array로 저장된다. . 여기에서 특정함수는 &quot;벡터입력-스칼라출력&quot;이라고 생각하자, 즉 벡터입력-스칼라입력인 함수를 적용할 수 있다. . sum(c(1,2,3,4)) # 벡터입력 -&gt; 스칼라출력 . [1] 10 . mean(c(1,2,3,4)) # 벡터입력 -&gt; 스칼라출력 . [1] 2.5 . 아래 함수는 벡터입력-벡터출력 이므로 해당되지 않는다. | . sqrt(c(1,2,3,4)) # 벡터입력 -&gt; 벡터출력 . [1] 1.000000 1.414214 1.732051 2.000000 . &#51201;&#50857; . A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . apply(A, 1, sum) . [1] 10 26 42 . apply(A, 1, mean) . [1] 2.5 6.5 10.5 . apply(A, 1, min) . [1] 1 5 9 . apply(A, 1, max) . [1] 4 8 12 . 사용자가 임의로 정의한 함수도 가능하다. | . f = function(a) (min(a)+1)**2 -3 . apply(A, 1, f) . [1] 1 33 97 . 숫자 1을 2로 변경하면 특정함수가 각각의 column에 적용된다. | . apply(A, 2, f) . [1] 1 6 13 22 . apply(A, 2, sum) . [1] 15 18 21 24 . apply(A, 2, min) . [1] 1 2 3 4 . apply(A, 2, max) . [1] 9 10 11 12 . %&gt;% &#50672;&#49328;&#51088;($ star star star$) . 아주 중요한 문법이다. . 아래는 같은 코드이다. | . library(tidyverse) . sum(1:10) . [1] 55 . 1:10 %&gt;% sum() . [1] 55 . 1:10 %&gt;% sum . [1] 55 . 아래는 같은 코드이다. | . myfun = function(x,y) x**2 +y myfun(2,3) . [1] 7 . myfun = function(x,y) x**2 +y 2 %&gt;% myfun(3) . [1] 7 . 아래는 같은 코드이다. | . myfun2 = function(x,y,z) x**2 +y*z myfun2(2,1,1) . [1] 5 . myfun2 = function(x,y,z) x**2 +y*z 2 %&gt;% myfun2(1,1) . [1] 5 . &#49324;&#50857;&#54616;&#45716; &#51060;&#50976; . 합성함수 처리가 쉽다. . | 아래는 같은 코드이다. . | . 2:5 %&gt;% log %&gt;% sqrt %&gt;% sum %&gt;% myfun2(1,1) %&gt;% sqrt . [1] 4.440805 . sqrt(myfun2(sum(sqrt(log(2:5))), 1, 1)) . [1] 4.440805 . 아래와 같은 느낌 | . $g(h(f(x)))$ . $x to f to h to g$ . &#49884;&#44036;&#48708;&#44368; . t1 = Sys.time() t1 . [1] &#34;2021-11-03 20:25:14 KST&#34; . t2 = Sys.time() t2 . [1] &#34;2021-11-03 20:25:14 KST&#34; . t2-t1 . Time difference of 0.156733 secs . A = sample(1:9, size =100*2000000, replace=TRUE) dim(A) &lt;- c(2000000,100) A . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [1,] 4 5 2 6 5 1 5 6 1 8 &lt;U+22EF&gt; 3 8 [2,] 7 3 2 4 5 9 3 1 5 2 &lt;U+22EF&gt; 3 9 [3,] 6 8 4 9 3 3 3 7 5 6 &lt;U+22EF&gt; 3 8 [4,] 6 5 9 6 7 5 1 6 7 7 &lt;U+22EF&gt; 7 3 [5,] 9 9 6 9 5 6 3 6 5 8 &lt;U+22EF&gt; 6 8 [6,] 4 4 8 1 7 3 4 9 4 1 &lt;U+22EF&gt; 8 4 [7,] 5 6 6 9 4 9 5 1 8 2 &lt;U+22EF&gt; 1 6 [8,] 6 8 6 5 6 8 8 2 3 2 &lt;U+22EF&gt; 3 1 [9,] 1 5 2 5 2 3 8 5 2 1 &lt;U+22EF&gt; 8 6 [10,] 3 4 2 9 9 9 5 7 3 4 &lt;U+22EF&gt; 9 3 [11,] 1 1 2 7 3 3 6 3 1 9 &lt;U+22EF&gt; 1 8 [12,] 3 6 9 6 9 9 7 2 9 2 &lt;U+22EF&gt; 8 6 [13,] 6 7 4 5 7 1 2 8 7 2 &lt;U+22EF&gt; 8 2 [14,] 4 8 8 7 6 3 5 4 5 4 &lt;U+22EF&gt; 5 7 [15,] 7 2 1 1 9 3 8 6 3 1 &lt;U+22EF&gt; 5 6 [16,] 9 8 5 3 2 7 1 7 6 3 &lt;U+22EF&gt; 1 6 [17,] 1 5 8 9 5 3 9 1 6 4 &lt;U+22EF&gt; 6 5 [18,] 7 1 9 9 7 5 9 4 2 3 &lt;U+22EF&gt; 7 5 [19,] 3 3 1 7 4 6 2 4 1 1 &lt;U+22EF&gt; 8 4 [20,] 5 3 5 3 1 2 9 4 6 8 &lt;U+22EF&gt; 1 7 [21,] 4 1 3 2 2 8 3 7 3 8 &lt;U+22EF&gt; 7 6 [22,] 1 7 9 9 6 3 1 9 7 8 &lt;U+22EF&gt; 6 9 [23,] 6 1 8 3 4 6 1 5 2 3 &lt;U+22EF&gt; 5 3 [24,] 1 6 9 2 4 2 3 8 5 4 &lt;U+22EF&gt; 5 1 [25,] 5 2 9 1 3 7 4 8 4 3 &lt;U+22EF&gt; 8 1 [26,] 6 8 5 1 9 4 1 8 7 1 &lt;U+22EF&gt; 8 7 [27,] 3 1 1 2 3 1 9 4 9 6 &lt;U+22EF&gt; 9 5 [28,] 4 2 3 1 8 3 2 4 2 7 &lt;U+22EF&gt; 2 6 [29,] 8 6 6 1 5 6 3 4 3 3 &lt;U+22EF&gt; 5 7 [30,] 6 2 9 3 6 7 8 1 3 6 &lt;U+22EF&gt; 2 9 [31,] &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22F1&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; [32,] 5 3 1 3 7 4 3 6 5 7 &lt;U+22EF&gt; 2 3 [33,] 6 1 6 5 4 1 5 1 6 6 &lt;U+22EF&gt; 6 5 [34,] 6 7 1 6 7 8 9 4 1 8 &lt;U+22EF&gt; 9 7 [35,] 8 7 8 1 3 9 4 3 6 9 &lt;U+22EF&gt; 4 2 [36,] 6 5 6 8 1 2 4 5 7 8 &lt;U+22EF&gt; 8 2 [37,] 7 1 9 5 9 5 9 2 6 2 &lt;U+22EF&gt; 3 3 [38,] 4 3 4 5 9 7 9 4 2 9 &lt;U+22EF&gt; 1 5 [39,] 7 4 2 8 9 8 5 4 4 3 &lt;U+22EF&gt; 9 9 [40,] 2 2 5 4 1 7 8 4 8 6 &lt;U+22EF&gt; 3 1 [41,] 5 7 9 8 4 7 9 9 8 2 &lt;U+22EF&gt; 8 3 [42,] 8 5 3 4 4 6 5 5 9 4 &lt;U+22EF&gt; 4 5 [43,] 2 8 5 5 6 1 8 4 7 3 &lt;U+22EF&gt; 4 2 [44,] 5 8 6 1 7 7 5 7 2 4 &lt;U+22EF&gt; 2 2 [45,] 6 6 6 3 6 3 7 8 5 8 &lt;U+22EF&gt; 7 9 [46,] 7 5 6 5 3 7 4 7 3 3 &lt;U+22EF&gt; 9 8 [47,] 3 4 2 2 5 4 6 4 3 9 &lt;U+22EF&gt; 9 4 [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [1,] 4 2 4 1 4 9 4 5 [2,] 4 7 7 9 4 5 4 7 [3,] 5 9 5 8 3 5 4 6 [4,] 2 9 1 8 5 9 1 2 [5,] 7 8 6 9 2 9 1 7 [6,] 7 9 9 3 9 7 2 6 [7,] 7 8 9 4 9 5 2 9 [8,] 9 4 2 8 9 6 6 1 [9,] 4 8 2 2 6 4 1 3 [10,] 1 3 3 4 2 2 5 8 [11,] 9 9 5 2 3 1 5 2 [12,] 4 7 4 4 2 5 1 1 [13,] 1 8 1 7 4 9 8 8 [14,] 7 1 8 6 4 1 8 2 [15,] 7 1 4 7 5 7 3 1 [16,] 8 7 1 2 6 4 2 3 [17,] 6 9 5 3 1 3 9 4 [18,] 8 4 9 4 7 2 9 7 [19,] 7 4 8 3 5 9 3 1 [20,] 5 7 6 6 8 1 6 8 [21,] 3 5 4 1 9 1 9 8 [22,] 5 3 9 9 9 8 3 5 [23,] 4 7 3 2 6 4 1 6 [24,] 9 1 3 4 2 3 2 5 [25,] 8 6 8 4 2 9 2 1 [26,] 6 3 4 4 6 9 1 2 [27,] 7 5 1 8 2 7 1 9 [28,] 2 6 3 3 7 6 4 8 [29,] 1 6 4 7 7 9 5 7 [30,] 9 1 7 4 5 1 9 1 [31,] &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; &lt;U+22EE&gt; [32,] 4 9 7 6 4 9 3 5 [33,] 5 1 1 2 9 2 5 1 [34,] 2 2 9 4 4 4 2 1 [35,] 1 2 8 5 7 6 2 5 [36,] 1 6 8 8 2 5 7 1 [37,] 7 4 8 1 9 1 8 8 [38,] 2 3 8 7 5 9 9 2 [39,] 3 9 5 5 3 6 2 5 [40,] 8 8 7 4 3 3 8 6 [41,] 2 3 1 7 8 4 6 7 [42,] 1 4 8 9 6 9 7 6 [43,] 4 3 8 9 7 8 9 8 [44,] 4 4 9 3 7 6 8 1 [45,] 7 8 9 9 6 2 5 7 [46,] 6 1 6 1 4 8 5 2 [47,] 5 2 5 8 5 9 5 4 [ getOption(&#34;max.print&#34;) 에 도달했습니다 -- 14 행들을 생략합니다 ] . . t1=Sys.time() A %&gt;% apply(1,min) %&gt;% max t2=Sys.time() t2-t1 . [1] 2 . Time difference of 10.82146 secs . t1 = Sys.time() vec &lt;- c() for (i in 1:dim(A)[1]) vec[i] &lt;- min(A[i,]) max(vec) t2=Sys.time() t2-t1 . [1] 2 . Time difference of 5.11485 secs . for문이 더 빠르지만 코드는 apply가 더 간결하다. | .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/25/R%EC%9E%85%EB%AC%B8-7%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/25/R%EC%9E%85%EB%AC%B8-7%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 25, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "숫자 카드 게임",
            "content": "Problem . 숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. . 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다. . 숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다. . | 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. . | 그 다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다. . | 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다. . | &#50696;&#49884;1 . 입력 3 1 2 4 1 4 2 2 2 . 출력 2 . &#50696;&#49884; 2 . 입력 7 3 1 8 3 3 3 4 . 출력 3 . Solution . A = rbind(c(3,1,2), c(4,1,4), c(2,2,2)) A . [,1] [,2] [,3] [1,] 3 1 2 [2,] 4 1 4 [3,] 2 2 2 . A[1,] . [1] 3 1 2 . A[2,] . [1] 4 1 4 . A[,1] . [1] 3 4 2 . A[1, 2] . [1] 1 . vec = c() for (i in 1:3){ vec[i] = min(A[i,]) } max(vec) . [1] 2 . &#44284;&#51228; . 입력이 아래와 같을 때, 출력을 구하는 코드를 작성하시오. . 입력 3 4 5 1 7 7 7 2 8 1 8 2 3 3 4 5 . A = rbind(c(3,4,5,1), c(7,7,7,2), c(8,1,8,2), c(3,3,4,5)) A . [,1] [,2] [,3] [,4] [1,] 3 4 5 1 [2,] 7 7 7 2 [3,] 8 1 8 2 [4,] 3 3 4 5 . Solution I . vec = c() for (i in 1:4){ vec[i] = min(A[i,]) } max(vec) . [1] 3 . Solution II . max(apply(A, 1, min)) #A : 입력 매트릭스, 1 : row기준, 2 : column기준 . [1] 3 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/19/R%EC%9E%85%EB%AC%B8-6%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/19/R%EC%9E%85%EB%AC%B8-6%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 19, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "R : 연산자",
            "content": "&#50672;&#49328;&#51088; . &#49328;&#49696;&#50672;&#49328;&#51088; . 사칙연산 : +, -, *, / | . 나머지연산 : %% | . 몫연산 : %/% | . 제곱 : a^b | . Example . 2+3 #덧셈 . [1] 5 . 6-2 #뺄셈 . [1] 4 . 4*8 #곱셈 . [1] 32 . 9/3 #나눗셈 . [1] 3 . 31 %% 7 #나머지 . [1] 3 . 31 %/% 7 #몫 . [1] 4 . 2^10 #제곱 . [1] 1024 . &#45436;&#47532;&#50672;&#49328;&#51088; . TRUE = 1 | . FALSE = 0 | . !TRUE = FALSE = 0 | . !FALSE = TRUE = 1 | . x = c(T,T,F,F,T) x . [1] TRUE TRUE FALSE FALSE TRUE . y = c(TRUE, FALSE, TRUE, FALSE, TRUE) y . [1] TRUE FALSE TRUE FALSE TRUE . print(x) print(!x) . [1] TRUE TRUE FALSE FALSE TRUE [1] FALSE FALSE TRUE TRUE FALSE . print(y) print(!y) . [1] TRUE FALSE TRUE FALSE TRUE [1] FALSE TRUE FALSE TRUE FALSE . Application . 1부터 100까지의 자연수 중 3의 배수만 출력하고 싶다. | . x = 1:100 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 . x[x %% 3 == 0] . [1] 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 [26] 78 81 84 87 90 93 96 99 . 1부터 100까지의 자연수 중 3의 배수가 아닌 것을 출력하고 싶다. | . x[x %% 3 != 0] . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 [20] 29 31 32 34 35 37 38 40 41 43 44 46 47 49 50 52 53 55 56 [39] 58 59 61 62 64 65 67 68 70 71 73 74 76 77 79 80 82 83 85 [58] 86 88 89 91 92 94 95 97 98 100 . x[!(x %% 3 == 0)] . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 [20] 29 31 32 34 35 37 38 40 41 43 44 46 47 49 50 52 53 55 56 [39] 58 59 61 62 64 65 67 68 70 71 73 74 76 77 79 80 82 83 85 [58] 86 88 89 91 92 94 95 97 98 100 . AND, OR . &amp; : AND . | : OR . TRUE&amp;TRUE . [1] TRUE . TRUE&amp;FALSE . [1] FALSE . FALSE&amp;TRUE . [1] FALSE . FALSE&amp;FALSE . [1] FALSE . TRUE|TRUE . [1] TRUE . TRUE|FALSE . [1] TRUE . FALSE|TRUE . [1] TRUE . FALSE|FALSE . [1] FALSE . &amp;&amp;, ||를 사용하면 첫 번째 원소만 비교 | . x = c(T,T,F,F,T) y = c(F,T,T,F,T) x&amp;&amp;y . [1] FALSE . x = c(T,T,F,F,T) y = c(T,T,T,F,T) x&amp;&amp;y . [1] TRUE . x = c(T,T,F,F,T) y = c(F,T,T,F,T) x||y . [1] TRUE . x = c(F,T,F,F,T) y = c(F,T,T,F,T) x||y . [1] FALSE . 아래처럼 해도 된다. | . x = c(T,T,F,F,T) y = c(F,T,T,F,T) (x&amp;y)[1] . [1] FALSE . x = c(T,T,F,F,T) y = c(T,T,T,F,T) (x&amp;y)[1] . [1] TRUE . x = c(T,T,F,F,T) y = c(F,T,T,F,T) (x|y)[1] . [1] TRUE . x = c(F,T,F,F,T) y = c(F,T,T,F,T) (x|y)[1] . [1] FALSE . &#48708;&#44368;&#50672;&#49328;&#51088; . a == b | . a != b | . a &gt;= b | . a &lt;= b | . 절대 =!, =&lt;. =&gt;로 쓰면 안된다. . &#54624;&#45817;&#50672;&#49328;&#51088; . a &lt;- 1 a . [1] 1 . 2 -&gt; a a . [1] 2 . a = 1 a . [1] 1 . a = b = 5 a b . [1] 5 . [1] 5 . a &lt;- b &lt;- 0 a b . [1] 0 . [1] 0 . a &lt;- 4 -&gt; b a b . [1] 4 . [1] 4 . f &lt;- function(x) x**2 f(100) . [1] 10000 . g = function(x) x**3 g(5) . [1] 125 . ; &#50672;&#49328;&#51088; . a=2; b=1 c(a, b) . [1] 2 1 . a=5;b=0; c(a,b) . [1] 5 0 . &#50672;&#49328;&#51088; &#50864;&#49440;&#49692;&#50948;&#50640; &#45824;&#54616;&#50668; . 연산자 우선순위에 의문이 드는 경우, 복잡하게 생각하지 말고 그냥 괄호를 사용하자 | . &#44284;&#51228; . $-100 leq x leq 100$의 범위에서 아래와 같은 y를 생성하라. . $y= begin{cases} x &amp; |x| &gt; 5 5 &amp; 2&lt;|x| leq 5 0 &amp; |x| leq 2 end{cases}$ . x = -100:100/10 x . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 -5.0 -4.9 -4.8 -4.7 -4.6 -4.5 -4.4 -4.3 -4.2 -4.1 [61] -4.0 -3.9 -3.8 -3.7 -3.6 -3.5 -3.4 -3.3 -3.2 -3.1 -3.0 -2.9 [73] -2.8 -2.7 -2.6 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 [85] -1.6 -1.5 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 [97] -0.4 -0.3 -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 [109] 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [121] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 [133] 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 [145] 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . y = ifelse(abs(x) &gt; 5, x, ifelse((2&lt;abs(x))&amp;(abs(x)&lt;=5), 5, 0)) .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-4%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-4%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "R : switch, repeat, break, next",
            "content": "switch() . switch(1, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 1 2 3 . switch(2, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 20 . switch(3, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 30 40 . switch(&#39;a1&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 1 2 3 . switch(&#39;a2&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 20 . switch(&#39;a3&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 30 40 . myfun &lt;- function(x,f){ switch(f, mean = mean(x), sqmean = mean(x**2), var = mean((x-mean(x))**2) ) } x = 1:5 myfun(x, &#39;mean&#39;) myfun(x, &#39;sqmean&#39;) myfun(x, &#39;var&#39;) . [1] 3 . [1] 11 . [1] 2 . repeat . repeat{ ~~ }는 while(TRUE){ ~~ }와 같다. . total=0 i=1 repeat{ if (i == 101) break total = total + i i = i + 1 } print(total) . [1] 5050 . break . 현재 반복문을 완전히 종료합니다. | . for (i in 1:5){ if (i == 3){ break }else { print(i) } } . [1] 1 [1] 2 . next . 현재 반복문의 해당 회차를 건너 뜁니다. | . for (i in 1:5){ if (i == 3){ next }else { print(i) } } . [1] 1 [1] 2 [1] 4 [1] 5 . for (i in 1:5){ if (i == 3) next else print(i)} . [1] 1 [1] 2 [1] 4 [1] 5 . total=0 i=1 while(TRUE){ if (i == 101) break total = total + i i = i + 1 } print(total) . [1] 5050 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-3%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-3%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "R : ifelse()",
            "content": "ifelse()&#51032; &#44592;&#48376; &#44396;&#51312; . ifelse(조건, 조건이 TRUE이면 실행, 조건이 FALSE이면 실행) . Problem . 절댓값을 출력하는 코드를 작성하라 | . Solution I . 다소 복잡한 코드 . 아래 코드는 복잡하다는 생각이 든다. | . absolute &lt;- function(x){ for (i in 1:length(x)){ if (x[i] &gt; 0){ x[i] = x[i] }else{ x[i] = -x[i] } } print(x) } x = -10:10 plot(absolute(x)) . [1] 10 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 10 . Solution II . ifelse문을 사용한 간결한 코드 . friend &lt;- function(x){ ifelse(x&gt;0, x, -x) } x = -10:10 friend(x) . [1] 10 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 10 . &#51060;&#47088; &#44163;&#46020; &#44032;&#45733; . y = ifelse(x &lt; 0, -x, ifelse(x &lt; 4, 0, x)) y plot(y) . [1] 10 9 8 7 6 5 4 3 2 1 0 0 0 0 4 5 6 7 8 9 10 . plot(x,x) points(x,y, col = 2, pch = 16) .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-2%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/07/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-2%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "평균과 비율에 대한 추론",
            "content": "from math import * . &#54217;&#44512;&#44284; &#48708;&#50984;&#50640; &#45824;&#54620; &#52628;&#47200; . 표본 통계량의 분포가 정규분포일 때, 신뢰구간은 다음과 같이 구한다. . 표본 통계량 $ pm z^* cdot SE$ . 임의화 분포가 정규분포일 때, 표준화한 검증 통계량은 다음과 같이 구한다. . $z = cfrac{ text{표본 통계량 - 영가설의 모수값}}{ text{표준오차}}$ . 2.1 &#48708;&#50984;&#50640; &#45824;&#54620; &#52628;&#47200; . 2.1-CI &#48708;&#50984;&#50640; &#45824;&#54620; &#49888;&#47280;&#44396;&#44036; . $ np geq 10, ,n(1-p) geq 10$이면 정규분포로 근사할 수 있다. . 표본 통계량 $ pm z^* cdot SE$ . $ hat{p} pm z^* cdot SE$ . $ hat{p} pm z^* sqrt{ dfrac{ hat{p}(1- hat{p})}{n}}$ . def ci_single_p(p, z, n): SE = sqrt(p*(1-p)/n) print(&quot;신뢰구간 : ({0}, {1})&quot;.format(p-z*SE, p+z*SE)) return . ci_single_p(0.52, 1.96, 100) . 신뢰구간 : (0.42207843138511314, 0.6179215686148869) . &#54364;&#48376; &#53356;&#44592; &#44208;&#51221;&#54616;&#44592; . 오차한계 $=z^* cdot SE = z^* cdot sqrt{ dfrac{ hat{p}(1- hat{p})}{n}}$ 이므로 . $n = left( cfrac{z^*}{ text{오차한계}} right)^2 hat{p}(1- hat{p})$ 이 때, 소수점이 있으면 올림한다. . 표본 비율 $ hat{p}$의 합리적인 추정이 가능하지 않다면 $ hat{p} = 0.5$를 사용한다. . def n_single_p(z, 오차한계, p_hat): print(&#39;n :&#39;,ceil((z/오차한계)**2 * p_hat*(1-p_hat))) return . n_single_p(2.327, 0.04, 0.5) . n : 847 . n_single_p(1.96, 0.01, 0.32) . n : 8360 . 2.1-HT &#48708;&#50984;&#50640; &#45824;&#54620; &#44032;&#49444;&#44160;&#51613; . $np_0 geq 10, ,n(1-p_0) geq10$이면 p-값은 표준정규분포에서 계산한다. . $z = cfrac{ text{표본 통계량 - 영가설의 모수값}}{ text{표준오차}}$ . $z = cfrac{ hat{p} - p_0}{SE}$ . $SE$&#45716; &#50612;&#46523;&#44172; &#52628;&#51221;&#54624; &#44163;&#51064;&#44032;? . 가설검증은 영가설 $H_0$가 참일 때 기대되는 분포에서 표본 비율 $ hat{p}$이 발생할 가능성을 평가한다. 영가설이 참임을 가정하므로 표준오차를 계산할 때 $p$ 대신에 $p_0$를 사용한다. 표준오차를 추정할 때, $ hat{p}$를 사용하면 절대로 안된다. . $SE = sqrt{ dfrac{p_0(1-p_0)}{n}}$ . $ therefore z = cfrac{ hat{p} - p_0}{ sqrt{ dfrac{p_0(1-p_0)}{n}}}$ . def test_single_p(p_hat, p_0, n): print(&#39;z :&#39;,(p_hat-p_0)/(sqrt(p_0*(1-p_0)/n))) return . test_single_p(0.59, 0.5, 340) . z : 3.3190360046254384 . test_single_p(0.555, 1/3, 119) . z : 5.129560166330054 . 위에서 구한 z-값으로 StatKey에서 p-값을 구한 뒤 기각 여부를 결정하자. . 2.2 &#54217;&#44512;&#50640; &#45824;&#54620; &#52628;&#47200; . $ dfrac{ sigma}{ sqrt{n}}$대신$ dfrac{s}{ sqrt{n}}$을 이용하여 표준화한 통계량의 분포는 표준정규분포가 아닌 t-분포이다. . $SE = dfrac{s}{ sqrt{n}}$ . def se_single_mean(s, n): print(&#39;SE :&#39;, s/sqrt(n)) return . 2.2-CI &#54217;&#44512;&#50640; &#45824;&#54620; &#49888;&#47280;&#44396;&#44036; . 표준정규분포 대신에 t-분포를 사용하기 때문에 $z^*$대신에 $t^*$를 사용한다. . 표본 통계량 $ pm ,z^* cdot dfrac{ sigma}{ sqrt{n}} approx $ 표본 통계량 $ pm ,t^* cdot dfrac{s}{ sqrt{n}} $ . $ bar{x} pm t^* cdot dfrac{s}{ sqrt{n}}$ . def ci_single_mean(x, t, s, n): print(&quot;신뢰구간 : ({0}, {1})&quot;.format(x-t*s/sqrt(n), x+t*s/sqrt(n))) return . ci_single_mean(369.52, 2.042, 16.16, 31) . 신뢰구간 : (363.593254927903, 375.446745072097) . &#54364;&#48376; &#53356;&#44592; &#44208;&#51221;&#54616;&#44592; . $ME = t^* dfrac{s}{ sqrt{n}}$ . 아직 표본이 없기 때문에 표준편차를 모른다. 따라서 $s$ 대신 $ tilde{ sigma}$로 추정한다. . $ tilde{ sigma}$를 합리적으로 추정하는 4가지 방법 . 선형 연구의 표준편차를 사용하거나 유사 모집단의 표본으로부터 $ tilde{ sigma}$를 추정한다. | 사전 조사로 작은 표본을 얻어 $ tilde{ sigma}$를 추정한다. | 모집단에서 범위(최댓값-최솟값)를 추정한다. 범위를 4로 나눈 값을 $ tilde{ sigma}$로 사용한다. 즉 $ tilde{ sigma} approx text{범위} / 4$이다. 이는 대부분의값들이 평균에서 두 배의 표준편차 안에 있을 것이라고 가정하는 것이다. | $ tilde{ sigma}$를 합리적으로 추측한다. | . $n = left( dfrac{t^* cdot s}{ME} right)^2 approx left( dfrac{t^* cdot tilde{ sigma}}{ME} right)^2$ . 2.2-HT &#54217;&#44512;&#50640; &#45824;&#54620; &#44032;&#49444;&#44160;&#51613; . $z = cfrac{ text{표본 통계량 - 영가설의 모수값}}{ text{표준오차}}$ . $ z = cfrac{ bar{x} - mu_0}{SE}$ . $ z = dfrac{ bar{x} - mu_0}{ dfrac{s}{ sqrt{n}}}$ . def test_single_mean(x, mu_0, s, n): print(&quot;t :&quot;, (x-mu_0)/(s/sqrt(n))) return . test_single_mean(37.5, 35, 38.2, 53) . t : 0.47644698228275634 . 2.3 &#48708;&#50984; &#52264;&#51060;&#50640; &#45824;&#54620; &#52628;&#47200; . 2.3-D. &#46160; &#44060;&#51032; &#48708;&#50984; &#52264;&#51060;&#51032; &#48516;&#54252; . $SE = sqrt{ dfrac{p_1(1-p_1)}{n_1} + dfrac{p_2(1-p_2)}{n_2}}$ . $n_1p_1 geq 10, , n_1(1-p_1) geq 10, , n_2p_2 geq 10, , n_2(1-p_2) geq 10$이면 정규분포로 근사할 수 있다. . 2.4-CI. &#46160; &#44060;&#51032; &#48708;&#50984; &#52264;&#51060;&#50640; &#45824;&#54620; &#49888;&#47280;&#44396;&#44036; . $n_1p_1 geq 10, , n_1(1-p_1) geq 10, , n_2p_2 geq 10, , n_2(1-p_2) geq 10$이면 정규분포로 근사할 수 있다. . 표본 통계량 $ pm z^* cdot SE$ . $( hat{p}_1 - hat{p}_2) pm z^* sqrt{ dfrac{ hat{p}_1(1- hat{p}_1)}{n_1} + dfrac{ hat{p}_2(1- hat{p}_2)}{n_2}}$ . def se_dif_p(p1, p2, n1, n2): print(&quot;SE :&quot;, sqrt(p1*(1-p1)/n1 + p2*(1-p2)/n2)) . def ci_dif_p(p1, p2, n1, n2, z): SE = sqrt(p1*(1-p1)/n1 + p2*(1-p2)/n2) ME = z*SE print(&quot;SE :&quot;, SE) print(&quot;ME :&quot;, ME) print(&quot;신뢰구간 : ({0}, {1})&quot;.format(p1-p2-z*SE, p1-p2+z*SE)) return . se_dif_p(0.72, 0.68, 500, 300) . SE : 0.03359365019365019 . ci_dif_p(0.72, 0.68, 500, 300, 1.96) . SE : 0.03359365019365019 ME : 0.06584355437955437 신뢰구간 : (-0.025843554379554448, 0.1058435543795543) . 2.3-HT &#48708;&#50984; &#52264;&#51060;&#50640; &#45824;&#54620; &#44032;&#49444;&#44160;&#51613; . 합동 비율 $ hat{p} = cfrac{X_1 + X_2}{n_1 + n_2}$ . $SE = sqrt{ cfrac{ hat{p}(1- hat{p})}{n_1} + cfrac{ hat{p}(1- hat{p})}{n_2}}$ . 영가설은 보통 $H_0 : p_1 = p_2$ 또는 $H_0 : p_1 - p_2 = 0$이다. 이 경수 영가설의 모수값은 0이다. . $z = cfrac{ text{표본 통계량 - 영가설의 모수값}}{ text{표준오차}}$ . $z = cfrac{( hat{p}_1 - hat{p}_2)}{SE}$ . $z = cfrac{( hat{p}_1 - hat{p}_2)}{ sqrt{ cfrac{ hat{p}(1- hat{p})}{n_1} + cfrac{ hat{p}(1- hat{p})}{n_2}}}$ . def test_dif_p(p_1, p_2, p_합, n_1, n_2): print(&quot;z :&quot;,(p_1 - p_2)/sqrt(p_합*(1-p_합)/n_1 + p_합*(1-p_합)/n_2)) return . test_dif_p(0.768, 0.463, 0.631, 82, 67) . z : 3.838160838927777 . 2.4 &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; &#52628;&#47200; . 2.4-D &#54217;&#44512; &#52264;&#51060;&#51032; &#48516;&#54252; . $SE = sqrt{ dfrac{ sigma_1^2}{n_1} + dfrac{ sigma_2^2}{n_2}}$ . def se_dif_mean(sigma1, sigma2, n1, n2): print(&quot;SE :&quot;, sqrt(sigma1**2/n1 + sigma2**2/n2)) return . se_dif_mean(8.8, 7.41, 20, 30) . SE : 2.387942629126588 . se_dif_mean(3.7, 7.6, 25, 40) . SE : 1.41124058898545 . se_dif_mean(18,14,8,15) . SE : 7.318925239860472 . se_dif_mean(1.7,1.8,230,230) . SE : 0.1632549353405387 . 0.9/0.163 . 5.521472392638037 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20statistics/2021/10/05/%ED%86%B5%EA%B3%84%ED%95%99-%EC%9E%85%EB%AC%B8-%ED%8F%89%EA%B7%A0%EA%B3%BC-%EB%B9%84%EC%9C%A8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B6%94%EB%A1%A0.html",
            "relUrl": "/introduction%20to%20statistics/2021/10/05/%ED%86%B5%EA%B3%84%ED%95%99-%EC%9E%85%EB%AC%B8-%ED%8F%89%EA%B7%A0%EA%B3%BC-%EB%B9%84%EC%9C%A8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B6%94%EB%A1%A0.html",
            "date": " • Oct 5, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "R : while()",
            "content": "while() &#51032; &#44592;&#48376; &#44396;&#51312; . while (조건){ (조건이 TRUE이면 실행, FALSE이면 PASS) } . Problem 1 . . Solution I - for . px = c() py = c() px[1] = 1 py[1] = 1 for (n in 1:2**12){ if ((px[n]==10)&amp;(py[n]==2^10)){ print(n) break }else{ if (py[n] &lt; 2**(px[n])){ px[n+1] = px[n] py[n+1] = py[n] + 1 }else{ px[n+1] = px[n] + 1 py[n+1] = 1 } } } . [1] 2046 . $n = 2046 = 2048 - 2 = 2^{11} - 2$ . Solution II - while . p_x = c() p_y = c() p_x[1] = 1 p_y[1] = 1 n = 1 while (TRUE){ if ((px[n]==10)&amp;(py[n]==2^10)){ print(n) break }else{ if (py[n] &lt; 2**(px[n])){ px[n+1] = px[n] py[n+1] = py[n] + 1 }else{ px[n+1] = px[n] + 1 py[n+1] } n = n + 1 } } . [1] 2046 . &#44284;&#51228; . for (x in (-5:100)){ if (x &gt;= 0){ break }else{ print(&quot;x는음수&quot;) } } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; . 1. 2007년 대학수학능력시험 9월 모의평가 수학영역(나형) 16번↩ .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/10/05/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-1%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/10/05/R%EC%9E%85%EB%AC%B8-5%EC%A3%BC%EC%B0%A8-1%ED%95%84%EA%B8%B0.html",
            "date": " • Oct 5, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Monte Carlo Integration in Python",
            "content": "&#47788;&#53580; &#52852;&#47484;&#47196; &#51201;&#48516;(Monte Carlo Integration) . Problem . Find $ int_0^1 (x + sin( pi x)) ,dx$. . Solution I - Analytic Sol . $ int_0^1 (x + sin( pi x)) ,dx = left[ cfrac{1}{2} x^2- cfrac{1}{ pi}cos( pi x) right]_0^1 = cfrac{1}{2} + cfrac{1}{ pi} + cfrac{1}{ pi} = cfrac{1}{2}+ cfrac{2}{ pi}$ . Solution II - Monte Carlo Integration in Python . import numpy as np import matplotlib.pyplot as plt . def function(x): return x + np.sin(np.pi*x) x = np.linspace(0, 1, 10000) y = [function(x) for x in x] plt.plot(x, y) plt.show() . . . S = 사각형 영역 . def function(x): #함수 정의 return x + np.sin(np.pi*x) N = 5000 # Random Sampling 시행 횟수 W = 1 # 사각형의 가로 길이 H = 1.6 #사각형의 세로 길이 X = np.random.random(N) # 0~1까지의 x 좌표 Random Sampling을 N번 시행 Y = H * np.random.random(N) # 그래프상 최솟값 ~ 최댓값까지의 y 좌표 Randon Sampling을 N번 시행 F = function(X) # Random Sampling으로 구한 X값에 따른 함숫값 in_or_out = Y &lt; F # Y &lt; F (IN)이면 True, Y &gt; F (OUT)이면 False A = H * W * np.sum(in_or_out) / N # 영역 S의 넓이 print(A) . 1.15328 . Visualization . color = list(map(lambda x: &#39;blue&#39; if x == True else &#39;red&#39;, in_or_out)) #색 정하기 x = np.linspace(0, 1, 10000) #함수 그리기 y = [function(x) for x in x] plt.plot(x, y, color = &#39;black&#39;) plt.scatter(X, Y, color = color, s=5, label=&#39;A = {}&#39;.format(np.round(A, 4))) plt.legend(loc = &#39;lower right&#39;) #범례(legend) 위치 plt.plot([0, W], [0, 0], color=&#39;black&#39;) # 사각형 영역 plt.plot([W, W], [0, H], color=&#39;black&#39;) plt.plot([0, W], [H, H], color=&#39;black&#39;) plt.plot([0, 0], [0, H], color=&#39;black&#39;) plt.xlabel(&#39;x&#39;) plt.ylabel(&#39;y&#39;) plt.grid() plt.show() .",
            "url": "https://stahangryum.github.io/stahangryum/python/2021/10/03/%EB%AA%AC%ED%85%8C-%EC%B9%B4%EB%A5%BC%EB%A1%9C.html",
            "relUrl": "/python/2021/10/03/%EB%AA%AC%ED%85%8C-%EC%B9%B4%EB%A5%BC%EB%A1%9C.html",
            "date": " • Oct 3, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "파이썬에서 그래프 그리기",
            "content": "import matplotlib . import matplotlib.pyplot as plt import numpy as np import scipy import sympy as sp . plt.plot([1, 2, 3, 4]) plt.show() . &#51221;&#44508;&#48516;&#54252; &#44536;&#47000;&#54532; . Normal Distribution | $N( mu, sigma^2)$ | . $f(x) = cfrac{1}{ sqrt{2 pi} sigma}e^{- cfrac{(x- mu)^2}{2 sigma^2}}$ . Standard Normal Distribution | $N(0, 1)$ | . $f(x) = cfrac{1}{ sqrt{2 pi}}e^{- cfrac{x^2}{2}}$ . def st_normal_distribution(x): f = np.sqrt(1/(2*np.pi))*(np.exp(-(x**2)/2)) return f x = range(-5, 5) y = [st_normal_distribution(x) for x in x] plt.plot(x, y) . [&lt;matplotlib.lines.Line2D at 0x236495dc7c0&gt;] . x = np.linspace(-5, 5, 10000) y = [st_normal_distribution(x) for x in x] plt.plot(x, y) plt.show() . x = np.random.normal(size =10000) plt.hist(x, bins=1000) plt.show() . &#54364;&#51456;&#51221;&#44508;&#48516;&#54252; &#47732;&#51201; &#44396;&#54616;&#44592; . &#47788;&#53580; &#52852;&#47484;&#47196; &#51201;&#48516; . def st_normal_distribution(x): return np.sqrt(1/(2*np.pi))*(np.exp(-(x**2)/2)) def area(X): N = int(1e+4) W = 2*X H = 0.5 X = W*np.random.random(N)-W/2 Y = H*np.random.random(N) F = st_normal_distribution(X) in_or_out = Y &lt; F A = H * W * np.sum(in_or_out) / N print(A) color = list(map(lambda x: &#39;blue&#39; if x == True else &#39;red&#39;, in_or_out)) #색 정하기 x = np.linspace(0, 1, 1000) #함수 그리기 y = [st_normal_distribution(x) for x in x] plt.plot(x, y, color = &#39;black&#39;) plt.scatter(X, Y, color = color, s=5, label=&#39;A = {}&#39;.format(np.round(A, 4))) plt.legend(loc = &#39;lower right&#39;) #범례(legend) 위치 plt.plot([0, W], [0, 0], color=&#39;black&#39;) # 사각형 영역 plt.plot([W, W], [0, H], color=&#39;black&#39;) plt.plot([0, W], [H, H], color=&#39;black&#39;) plt.plot([0, 0], [0, H], color=&#39;black&#39;) plt.xlabel(&#39;x&#39;) plt.ylabel(&#39;y&#39;) plt.grid() plt.show() . area(1.96) # 95% 신뢰구간 . 0.9535399999999999 . area(2.58) # 99% 신뢰구간 . 0.974982 . area(1.645) # 90% 신뢰구간 . 0.8999795 . &#48512;&#51221;&#51201;&#48516; . def st_normal_distribution(x): f = np.sqrt(1/(2*np.pi))*(np.exp(-(x**2)/2)) return f .",
            "url": "https://stahangryum.github.io/stahangryum/python/2021/10/03/%EA%B7%B8%EB%9E%98%ED%94%84.html",
            "relUrl": "/python/2021/10/03/%EA%B7%B8%EB%9E%98%ED%94%84.html",
            "date": " • Oct 3, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Taylor & Maclaurin Series",
            "content": "Taylor Series . $ f(x) = sum_{n=0}^ infty cfrac{f^{(n)}(a)}{n!}(x-a)^n qquad quad= f(a) + cfrac{f&#39;(a)}{1!}(x-a) + cfrac{f&#39;&#39;(a)}{2!}(x-a) + cfrac{f&#39;&#39;&#39;(a)}{3!}(x-a)+ cdots $ . Maclaurin Series . $ f(x) = sum_{n=0}^ infty cfrac{f^{(n)}(0)}{n!}(x-0)^n qquad quad = f(a) + cfrac{f^{ prime}(0)}{1!}(x-0) + cfrac{f^{ prime prime}(0)}{2!}(x-0) + cfrac{f^{ prime prime prime}(0)}{3!}(x-0)+ cdots $ . Examples . $ cfrac{1}{1-x} = sum_{n=0}^ infty{x^n} = 1+x+x^2+x^3+ cdots qquad R = 1 , e^x = sum_{n=0}^ infty cfrac{x^n}{n!} = 1 + cfrac{x}{1!} + cfrac{x^2}{2!} + cfrac{x^3}{3!}+ cdots qquad R = infty , sin ,x = sum_{n=0}^ infty(-1)^n cfrac{x^{2n+1}}{(2n+1)!} = x - cfrac{x^3}{3!} + cfrac{x^5}{5!} - cfrac{x^7}{7!}+ cdots qquad R = infty , cos ,x = sum_{n=0}^ infty(-1)^n cfrac{x^{2n}}{(2n)!} = 1 - cfrac{x^2}{2!} + cfrac{x^4}{4!} - cfrac{x^6}{6!}+ cdots qquad R = infty , tan^{-1} ,x = sum_{n=0}^ infty(-1)^n cfrac{x^{2n+1}}{(2n+1)} = x - cfrac{x^3}{3} + cfrac{x^5}{5} - cfrac{x^7}{7}+ cdots qquad R = 1 , ln(1+x) = sum_{n=1}^ infty(-1)^{n-1} cfrac{x^{n}}{n} = x - cfrac{x^2}{2} + cfrac{x^3}{3} - cfrac{x^4}{4}+ cdots qquad R = 1 $ .",
            "url": "https://stahangryum.github.io/stahangryum/calculus/2021/10/02/%ED%85%8C%EC%9D%BC%EB%9F%AC-%EA%B8%89%EC%88%98.html",
            "relUrl": "/calculus/2021/10/02/%ED%85%8C%EC%9D%BC%EB%9F%AC-%EA%B8%89%EC%88%98.html",
            "date": " • Oct 2, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "R : if()",
            "content": "&#51312;&#44148;&#47928;&#51032; &#44592;&#48376; &#44396;&#51312; . if (조건1){ (조건1이 TRUE이면 실행, FALSE이면 pass) } else if (조건2){ (조건1이 FALSE이고 조건2가 TRUE일 때 실행,) } else { (조건1과 조건2가 모두 FALSE일 때 실행) . Example . a = 10 if (a &gt; 0){ print(&quot;a는 양수이다.&quot;) } else if (a &lt; 0){ print(&quot;a는 음수이다.&quot;) } else if (a == 0){ print(&quot;a는 0이다.&quot;) } else { print(&quot;a는 실 수가 아니다.&quot;) } . [1] &#34;a는 양수이다.&#34; . NOTE . 다음과 같은 코드는 가급적 작성하지 마시오. . 임의로 Space나 Enter를 넣어도 상관없다. | 다만, 가독성 떨어질 수 있으니 유의하라. | . if (a &gt; 0) {print(&quot;a는 양수이다.&quot;)} . [1] &#34;a는 양수이다.&#34; . if (a &gt; 0){ print(&quot;a는 양수이다.&quot;)} . [1] &#34;a는 양수이다.&#34; . 조건에 벡터가 사용될 경우, 첫 번째 요소만이 사용된다. | 다만, 굳이 코드를 이렇게 작성할 필요는 없다. | . if ((4:10) &gt; 3){ print(&quot;우엉징&quot;) } . Warning message in if ((4:10) &gt; 3) {: &#34;length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다&#34; . [1] &#34;우엉징&#34; . 위 코드의 조건문을 보면, 좌변에서 벡터의 첫 번째 요소인 &#39;4&#39;가 사용되었으므로 (4 &gt; 3) &lt;- TRUE . if ((2:10) &gt; 3){ print(&quot;우징엉&quot;) } . Warning message in if ((2:10) &gt; 3) {: &#34;length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다&#34; . 위 코드의 조건문을 보면, 좌변에서 벡터의 첫 번째 요소인 &#39;2&#39;가 사용되었으므로 (2 &gt; 3) &lt;- TRUE . NOTE2 . 아래는 잘못된 예이다. | . if (5 &gt; 3){ print(&quot;우징엉&quot;) } else{ print(&quot;오징엉&quot;) } . Error in parse(text = x, srcfile = src): &lt;text&gt;:4:1: 예기치 않은 &#39;else&#39;입니다 3: } 4: else ^ Traceback: . 위 코드에서, LINE3에서 컴퓨터는 조건문이 완전히 종료된 것으로 인식하였다. | 그런데 갑자기 else를 마주하자 오류를 낸 것. | . 아래는 옳은 예이다. | . if (5 &gt; 3) { print(&quot;우징엉&quot;) } else { print(&quot;오징엉&quot;) } . [1] &#34;우징엉&#34; . 위 코드처럼 코드가 끝나지 않았음을 컴퓨터에게 알려줘야 한다. | . &#44284;&#51228; . if문을 활용하여 제곱근을 계산하는 함수를 만드시오. | . mysqrtfun &lt;- function(x){ if (x &gt;= 0){ print(sqrt(x)) }else{ print(&quot;x는 양수이어야 합니다.&quot;) } } . mysqrtfun(-2) . [1] &#34;x는 양수이어야 합니다.&#34; . mysqrtfun(2) . [1] 1.414214 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/09/30/R%EC%9E%85%EB%AC%B8-4%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/09/30/R%EC%9E%85%EB%AC%B8-4%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "R : for()",
            "content": "Problem 1 . . Solution I . $f(a) = cfrac{2^a+2^{-a}}{2^{a}-2^{-a}}$에서 $f(a) =-2$를 만족하는 a를 구해보자. . f &lt;-function(a){ (2**a + 2**(-a))/(2**a - 2**(-a)) } . $f(a)$의 그래프를 그리고 $f(a) = -2$에 해당하는 수평선을 그려서 a의 대략적인 범위를 구해보자. . a = seq(from = -5, to = 5, by = 0.1) plot(a, f(a)) abline(h= -2, col = &quot;red&quot;) . $-2&lt;a&lt;0$임을 알았다. . 범위를 좁히고, by 옵션을 사용하여 더 촘촘히 다시 그려보자. . a = seq(from = -1, to = -0.5, by = 0.0001) plot(a, f(a), type = &quot;l&quot;, lwd = 4) abline(h = -2, col = &quot;red&quot;, lwd = 4) . $-0.9 &lt; a &lt; -0.8$임을 알았다. . - 이제 해를 찾아보자. $f(a) = -2$를 찾아야 하므로 f(a) == -2를 조건식으로 걸자 . a = seq(from = -0.9, to = -0.7, by = 0.0001) f(a) == -2 . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [805] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [817] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [829] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [841] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [853] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [865] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [877] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [889] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [901] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [913] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [925] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [937] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [949] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [961] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [973] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [985] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [997] FALSE FALSE FALSE FALSE [ reached getOption(&#34;max.print&#34;) -- omitted 1001 entries ] . . 이중에 적당한 값(TRUE)가 있을까? | . TRUE가 있는지 체크할 수 있는 방법은 없을까? | . True and False . 컴퓨터는 TRUE, FALSE를 각각 1, 0으로 인식한다. . print(TRUE + FALSE) . [1] 1 . print(TRUE * 2) . [1] 2 . print(2 * c(TRUE, FALSE, TRUE)) . [1] 2 0 2 . sum(c(TRUE, FALSE, TRUE)) . [1] 2 . Application . sum(f(a) == 2) . [1] 0 . 어? 없네 . 사실 컴퓨터는 근사계산을 하였으므로 $f(a) = -2$인 경우를 정확하게 찾기는 힘들다. . 따라서 적당한 근사값인 $f(a) approx -2$인 경우를 찾는게 더 합리적이다. . $|f(a) + 2|$이 최솟값을 갖게하는 $a$를 구해도 무방하다. . min(abs(f(a) + 2)) # f(a) + 2d의 절댓값 중 가장 작은 값 . [1] 3.898777e-05 . min 함수를 사용하면 최솟값을 구할 수 있다. . abs 함수를 사용하면 절댓값을 구할 수 있다. . plot(abs(f(a) + 2)) . TFarray &lt;- abs(f(a) + 2) == min(abs(f(a) + 2)) a[TFarray] . [1] -0.7925 . $a approx -0.7925$ . $ therefore 4^{a} + 4^{-a} approx 4^{-0.7925} + 4^{0.7925} $ . print(4**0.7925 + 4**(-0.7925)) . [1] 3.333403 . print(c(5/2, 10/3,17/4,26/5,37/6)) . [1] 2.500000 3.333333 4.250000 5.200000 6.166667 . 고로 답은 2번이다. . Problem 2 . . Solution I - &#47924;&#51648;&#49457; &#45824;&#51077; . $a_{n+1} + a_n = (-1)^{n+1} times n$ . $a_{n+1} = -a_n + (-1)^{n+1} times n$ . a1=12 n=1 a2= -a1+(-1)^(n+1)* n n=2 a3= -a2+(-1)^(n+1)* n n=3 a4= -a3+(-1)^(n+1)* n n=4 a5= -a4+(-1)^(n+1)* n n=5 a6= -a5+(-1)^(n+1)* n n=6 a7= -a6+(-1)^(n+1)* n n=7 a8= -a7+(-1)^(n+1)* n n=8 a9= -a8+(-1)^(n+1)* n n=9 a10= -a9+(-1)^(n+1)* n a=c(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 . $k$의 최솟값은 $8$ | . Solution II - for&#47928; . $a_{n+1} + a_n = (-1)^{n+1} times n$ . $a_{n+1} = -a_n + (-1)^{n+1} times n$ . - 예비학습 . a_ &lt;- c() print(a_) . NULL . a_[1] &lt;- 12 print(a_) . [1] 12 . a_[2] &lt;- -12 print(a_) . [1] 12 -12 . a_[4] &lt;- 3 print(a_) . [1] 12 -12 NA 3 . a &lt;- c() a[1] &lt;- 12 . for(n in 1:10){ a[n+1] &lt;- -a[n] + (-1)**(n+1) * n } print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 -43 . . print((1:20)[a&gt;12]) . [1] 8 10 19 . 조건을 만족하는 $k$의 최솟값은 $8$ | . Problem 3 . . Solution . sal &lt;- c() sal[1] &lt;- 1 # 첫해의 연봉은 1로 하자. . for(i in 2:19){ sal[i] &lt;- sal[i-1] * 1.08 #조건 (가) } sal[20:28] = 2/3 * sal[19] #조건 (나) print(sal) . sum(sal) . [1] 65.42238 . $65.42238a approx cfrac{131}{2}a$이므로 . 28년 동안 근무하여 받는 연봉의 총합은 $ cfrac{131}{2}a$ . Problem 4 . . Solution . x = c() x[1] = 5 x[2] = 5 for (n in 3:100){ temp_ = mean(x[1:(n-1)]) + 1 # temp_ = x_1부터 x_n까지의 평균 sum_ = temp_ * n # sum_ = x_1부터 x_n까지의 합 x[n] = sum_ - sum(x[1:n-1]) # x[n] = x_1부터 x_n까지의 합 - x_1부터 x_{n-1}까지의 합 } x[100] . [1] 202 . $x_{100} = 202$ . Problem 5 . . Solution . a &lt;- c() a[1] = 0 # 첫째항은 0이라고 하자. a[2] = 1 . $S_n$은 $n$이 짝수인지, 홀수인지에 따라서 정의가 달라진다. . $S_3 = S_1 - 3$ . $S_5 = S_3 - 3$ . ... . $S_4 = S_2 + 2$ . $S_6 = S_4 + 2$ . ... . S &lt;- c() S[1] = a[1] S[2] = a[1] + a[2] . &#45208;&#47672;&#51648;&#47484; &#44396;&#54616;&#45716; &#50672;&#49328;&#51088; %% . 짝수, 홀수를 구분할 때 사용하면 좋다. | . (1:10) . [1] 1 2 3 4 5 6 7 8 9 10 . (1:10) %% 2 # 2로 나누었을 때의 나머지, 홀수는 1, 짝수는 0 . [1] 1 0 1 0 1 0 1 0 1 0 . for(n in 3:50){ if (n %% 2 == 1){ #n이 홀수인 경우 S[n] = S[n-2] - 3 } else if(n %% 2 == 0){ # n이 짝수인 경우 S[n] = S[n-2] + 2 } else{print(&quot;Error&quot;)} } S . [1] 0 1 -3 3 -6 5 -9 7 -12 9 -15 11 -18 13 -21 15 -24 17 -27 [20] 19 -30 21 -33 23 -36 25 -39 27 -42 29 -45 31 -48 33 -51 35 -54 37 [39] -57 39 -60 41 -63 43 -66 45 -69 47 -72 49 . $a_n = S_n - S_{n-1}$ 이므로 . for(n in 3:50){ a[n] = S[n] - S[n-1] } a . [1] 0 1 -4 6 -9 11 -14 16 -19 21 -24 26 -29 31 -34 [16] 36 -39 41 -44 46 -49 51 -54 56 -59 61 -64 66 -69 71 [31] -74 76 -79 81 -84 86 -89 91 -94 96 -99 101 -104 106 -109 [46] 111 -114 116 -119 121 . a[8] . [1] 16 . $ therefore a_8 = 16$ . &#44284;&#51228; . $a_1$이 달라지면 어떻게 되는지 확인하라. | . a &lt;- c() a[1] = 5 # 첫째항은 5이라고 하자. a[2] = 1 S &lt;- c() S[1] = a[1] S[2] = a[1] + a[2] for(n in 3:100){ if (n %% 2 == 1){ #n이 홀수인 경우 S[n] = S[n-2] - 3 } else if(n %% 2 == 0){ # n이 짝수인 경우 S[n] = S[n-2] + 2 } else{print(&quot;Error&quot;)} } for(n in 3:100){ a[n] = S[n] - S[n-1] } a[8] . [1] 16 . $a_1$이 달라지면 $s_n$은 달라지지만 $a_n (n geq 2)$은 달라지지 않는다. | . 1. 2005년 대학수학능력시험 6월 모의평가 수리영역(나형) 4번↩ . 2. 2021년 대학수학능력시험 9월 모의평가 수학영역(가형) 10번↩ . 3. 2007년 대학수학능력시험 6월 모의평가 수리영역(나형) 14번↩ . 4. 2007년 대학수학능력시험 수리영역(인문계) 19번↩ . 5. 2010년 대학수학능력시험 수리영역(나형) 30번↩ .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/09/17/R%EC%9E%85%EB%AC%B8-3%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/09/17/R%EC%9E%85%EB%AC%B8-3%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Sep 17, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "시계열그래프를 그리는 방법",
            "content": "&#45936;&#51060;&#53552;&#51032; &#51333;&#47448; . 데이터를 시계열자료, 횡단면자료, 패널자료로 구분한다. | . &#49884;&#44228;&#50676;&#51088;&#47308; . 시간의 변화에 따라 얻는 자료를 시계열자료(time-series data) 라고 한다. . 예를 들어 연도별 이자율, 월별 평균 온도, 매 4년마다 우리나라 올림픽 메달 수는 시계열자료이다. . &#54945;&#45800;&#47732;&#51088;&#47308; . 동시간 대에 얻는 자료를 횡단면자료(cross-sectional data) 라고 한다. . 예를 들어 은행별 이자율, 도시별 온도, 역대 올림픽에서 금메달을 획득한 종목은 횡단면자료이다. . &#54056;&#45328;&#51088;&#47308; . 횡단면자료가 시간에 따라 나열되어 있는 것이 패널자료(panel data) 이다. . 예를 들어 아파트 가격이 지역별, 연도별로 되어 있으면 패널자료이다. . R&#50640;&#49436; &#49884;&#44228;&#50676; &#44536;&#47000;&#54532; &#44536;&#47532;&#44592; . R 함수와 그래프 그리는 방법 소개 | . stocks &lt;- scan(&quot;istat_data SamsungElectronicsStocks.txt&quot;) times &lt;- c(1:length(stocks)) . print(head(times)) . [1] 1 2 3 4 5 6 . head 함수는 처음 6개의 데이터를 출력하는 함수이다. . print(seq(1, 10, 3)) . [1] 1 4 7 10 . print(seq(from = 1, to = 10, by = 3)) . [1] 1 4 7 10 . seq(a, b, c) 또는 seq(from = a, to = b, by = c) 를 사용하면 숫자 a 부터 b 까지 간격이 c인 수열을 생성한다. . ts.plot &#54632;&#49688;&#47484; &#51060;&#50857;&#54620;&#45796;. . ts.plot(stocks, main = &quot;삼성전자 주가&quot;) . &#51068;&#48152; plot &#54632;&#49688;&#50640; &#50741;&#49496; type = &quot;l&quot; &#51012; &#52628;&#44032;&#54620;&#45796;. . plot(times, stocks, main = &quot;삼성전자 주가&quot;) . par(mfcol = c(2,1)) plot(times, stocks) .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20statistics/2021/09/13/%ED%86%B5%EA%B3%84%ED%95%99%EC%9E%85%EB%AC%B8-1%EC%9E%A5.html",
            "relUrl": "/introduction%20to%20statistics/2021/09/13/%ED%86%B5%EA%B3%84%ED%95%99%EC%9E%85%EB%AC%B8-1%EC%9E%A5.html",
            "date": " • Sep 13, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "R : 변수, 벡터, 함수",
            "content": "&#48320;&#49688;&#50640; &#50612;&#46496;&#54620; &#44050;&#51012; &#45347;&#45716; &#48169;&#48277; . &#48169;&#48277;1 : = &#51060;&#50857; . a = 1 . print(a) . [1] 1 . &#48169;&#48277;2 : &lt;-&#51060;&#50857; . b &lt;- 3 . print(b) . [1] 3 . &#48320;&#49688; &#51060;&#47492;&#51012; &#49444;&#51221;&#54624; &#46412; &#51452;&#51032;&#54624; &#51216; . - &#48320;&#49688; &#51060;&#47492;&#51008; &#49707;&#51088;&#47196;&#47564; &#44396;&#49457;&#54624; &#49688; &#50630;&#45796;. . 444 &lt;- 5 . Error in 444 &lt;- 5: 대입에 유효하지 않은 (do_set) 좌변입니다 Traceback: . - &#48320;&#49688; &#51060;&#47492;&#51008; &#53945;&#49688;&#47928;&#51088;&#47196; &#44396;&#49457;&#54624; &#49688; &#50630;&#45796;. . ^^@ &lt; - 4 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:1: 예기치 않은 &#39;^&#39;입니다 1: ^ ^ Traceback: . - &#48320;&#49688; &#51060;&#47492;&#50640; &#46916;&#50612;&#50416;&#44592;&#47484; &#49324;&#50857;&#54624; &#49688; &#50630;&#45796;. . Kim Jeewoo &lt;- 4 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:5: 예상하지 못한 기호(symbol)입니다. 1: Kim Jeewoo ^ Traceback: . - &#46916;&#50612;&#50416;&#44592; &#45824;&#49888; &#50616;&#45908;&#48148;(_)&#47484; &#49324;&#50857;&#54616;&#45716; &#44163;&#51008; &#44032;&#45733;&#54616;&#45796;. . - &#45800;, &#48320;&#49688; &#51060;&#47492;&#51012; &#50616;&#45908;&#48148;&#47196; &#39;&#49884;&#51089;&#39;&#54624; &#49688; &#50630;&#45796;. . Kim_Jeewoo &lt;- 4 Kim.Jeewoo &lt;- 5 . - &#48320;&#49688; &#51060;&#47492;&#51008; &#49707;&#51088;&#47196; &#39;&#49884;&#51089;&#39;&#54624; &#49688; &#50630;&#45796;. . 1a &lt;- 3 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:2: 예상하지 못한 기호(symbol)입니다. 1: 1a ^ Traceback: . - &#51060;&#44148; &#44032;&#45733;&#54616;&#45796; . a1 &lt;- 3 . &#44032;&#45733;&#51008; &#54616;&#45208; &#44428;&#51109;&#54616;&#51648; &#50506;&#45716; &#48320;&#49688; &#51060;&#47492; . print(pi) . [1] 3.141593 . pi&lt;-333 . print(pi) . [1] 333 . 원래 내장된 $ pi$가 날아가버렸다... . &#48320;&#49688; &#49373;&#49457;&#49884; &#54017; . - &#48320;&#49688;&#47484; &#52629;&#50557;&#54624; &#46412; &#47784;&#51020;&#51012; &#51228;&#50808;&#54616;&#47732; &#51339;&#45796;. . result -&gt; rslt | residual -&gt; rsdl | . - &#51076;&#49884;&#47196; &#48320;&#49688;&#47749;&#51012; &#49324;&#50857;&#54644;&#50556; &#54624; &#44221;&#50864; &#48320;&#49688; &#51060;&#47492; &#45149;&#50640; &#50616;&#45908;&#48148;&#47484; &#48537;&#51064;&#45796;. . x, y, rslt_, rsdl | . &#48289;&#53552;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . &#48169;&#48277;1 - &#51649;&#51217; &#51077;&#47141; . v1 &lt;- c(1, 2, 3, 3, 4, 5, 2) . print(v1) . [1] 1 2 3 3 4 5 2 . &#48169;&#48277;2 - seq&#47484; &#51060;&#50857; . ?seq #실행하면 seq의 사용법에 대해 알려준다. . v2 &lt;- seq(from=0, to=10, by=0.1) #0부터 10까지 0.1 단위로 벡터 생성! . print(v2) . [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 [16] 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 [31] 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 4.4 [46] 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 [61] 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 [76] 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 [91] 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . print(seq(from=0, to=1, length.out = 57)) #0부터 1까지 10등분 . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . &#48169;&#48277;3 - : &#51060;&#50857; . print(0:56) . [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [26] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 [51] 50 51 52 53 54 55 56 . print(0:56 / 56) . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . &#48169;&#48277;4 - rep &#51060;&#50857; . print(rep(0,22)) #0을 22번 반복 . [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . print(rep(4,12)) #4를 12번 반복 . [1] 4 4 4 4 4 4 4 4 4 4 4 4 . print(rep(5, 77)) . [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 [39] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 [77] 5 . &#54632;&#49688;&#47484; &#49324;&#50857;&#54616;&#45716; &#48169;&#48277; . - &#44592;&#48376; &#44396;&#51312; . 함수 이름 &lt;- function(입력){ 함수의 기능 return 출력 } . - &#50696;&#49884; . f &lt;- function(d){ y=2^(-0.25*d) return(y) } . f(8) . 0.25 - return&#51012; &#49373;&#47029;&#54644;&#46020; &#44316;&#52270;&#45796;. . g &lt;- function(d){ y=2^(-0.25*d) y } . g(8) . 0.25 &#48289;&#53552;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . x &lt;- c(1,2,-2,4,5,-5,6) print(x) . [1] 1 2 -2 4 5 -5 6 . &#50896;&#49548;&#51032; &#48264;&#54840;&#47484; &#48520;&#47084;&#49436; &#48977;&#45716; &#48169;&#48277; . - &#52395;&#48264;&#51704; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . 파이썬과 다르게 인덱싱은 1부터 시작한다. . print(x[1]) . [1] 1 . - &#46160;&#48264;&#51704; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x[3]) . [1] -2 . - &#52395;&#48264;&#51704;&#48512;&#53552; &#49464;&#48264;&#51704;&#44620;&#51648;&#51032; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x[1:3]) . [1] 1 2 -2 . print(x[c(1,2,3)]) . [1] 1 2 -2 . - 2, 5, 6 &#48264;&#51704;&#51032; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x[c(2, 5, 6)]) . [1] 2 5 -5 . - 3&#48264;&#51704; &#50896;&#49548;&#47484; &#51228;&#50808;&#54616;&#44256; &#48977;&#44256;&#49910;&#45796;. . print(x) . [1] 1 2 -2 4 5 -5 6 . print(x[-3]) . [1] 1 2 4 5 -5 6 . - 3, 4&#48264;&#51704;&#51032; &#50896;&#49548;&#47484; &#51228;&#50808;&#54616;&#44256; &#48977;&#44256;&#49910;&#45796;. . print(x[-c(3,4)]) . [1] 1 2 5 -5 6 . print(x[-(3:4)]) . [1] 1 2 5 -5 6 . &#50612;&#46496;&#54620; &#51312;&#44148;&#51012; &#51452;&#44256;, &#44536; &#51312;&#44148;&#50640; &#47564;&#51313;&#54616;&#45716; &#50896;&#49548; (&#54841;&#51008; &#47564;&#51313;&#54616;&#51648; &#50506;&#45716; &#50896;&#49548;)&#47484; &#48977;&#45716; &#48169;&#48277; . - &#50577;&#49688;&#51064; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x) . [1] 1 2 -2 4 5 -5 6 . (1) 양수인지 스스로 판단 . (2) 양수라면 나간다. . print(x&gt;0) . [1] TRUE TRUE FALSE TRUE TRUE FALSE TRUE . x&gt;0의 결과는 TRUE, FALSE가 포함된 벡터 . print(x[x&gt;0]) . [1] 1 2 4 5 6 . - 3&#51060;&#49345;&#51064; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x&gt;3) . [1] FALSE FALSE FALSE TRUE TRUE FALSE TRUE . print(x[x&gt;3]) . [1] 4 5 6 . - TRUE &#46308;&#50668;&#45796;&#48372;&#44592; . print(x) . [1] 1 2 -2 4 5 -5 6 . array_ = c(TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE) . print(array_) . [1] TRUE FALSE TRUE FALSE FALSE FALSE FALSE . print(x[array_]) . [1] 1 -2 . - &#44050;&#51060; -2&#51064; &#50896;&#49548;&#47484; &#48977;&#44256;&#49910;&#45796;. . print(x) . [1] 1 2 -2 4 5 -5 6 . print(x[x == -2]) . [1] -2 . - &#51025;&#50857;&#50696;&#51228; 1 . x &lt;- c(1,2,3,4,5) y &lt;- x^2 . print(x) . [1] 1 2 3 4 5 . print(y) . [1] 1 4 9 16 25 . $y=9$가 되도록 하는 $x$를 구하고싶다. | . print(x[y == 9]) . [1] 3 . - &#51025;&#50857;&#50696;&#51228; 2 - &#54980;&#49696; . 후술 | . &#44536;&#47548;&#51012; &#44536;&#47532;&#45716; &#48277; . x &lt;- 1:60/10 print(x) . [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [20] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 [39] 3.9 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 [58] 5.8 5.9 6.0 . y &lt;- sin(x) y . &lt;ol class=list-inline&gt;0.0998334166468282 | 0.198669330795061 | 0.29552020666134 | 0.389418342308651 | 0.479425538604203 | 0.564642473395035 | 0.644217687237691 | 0.717356090899523 | 0.783326909627483 | 0.841470984807897 | 0.891207360061435 | 0.932039085967226 | 0.963558185417193 | 0.98544972998846 | 0.997494986604054 | 0.999573603041505 | 0.991664810452469 | 0.973847630878195 | 0.946300087687414 | 0.909297426825682 | 0.863209366648874 | 0.80849640381959 | 0.74570521217672 | 0.675463180551151 | 0.598472144103957 | 0.515501371821464 | 0.42737988023383 | 0.334988150155905 | 0.239249329213982 | 0.141120008059867 | 0.0415806624332905 | -0.0583741434275801 | -0.157745694143248 | -0.255541102026831 | -0.35078322768962 | -0.442520443294852 | -0.529836140908493 | -0.611857890942719 | -0.687766159183974 | -0.756802495307928 | -0.81827711106441 | -0.871575772413588 | -0.916165936749455 | -0.951602073889516 | -0.977530117665097 | -0.993691003633464 | -0.999923257564101 | -0.996164608835841 | -0.982452612624332 | -0.958924274663138 | -0.925814682327732 | -0.883454655720153 | -0.832267442223901 | -0.772764487555987 | -0.705540325570392 | -0.631266637872322 | -0.550685542597638 | -0.464602179413757 | -0.373876664830236 | -0.279415498198926 | &lt;/ol&gt; plot(x, y) . plot(x, y^2) . plot(x,y) lines(x, y^2) . plot(x, y) points(x, y^2) . plot(x, y, type=&#39;l&#39;) lines(x, y^2) . plot(x, y, type =&#39;l&#39;, col=&#39;blue&#39;) lines(x, y^2, type = &#39;p&#39;, col = &#39;#ADD826&#39;) lines(x, y^6 - y^3, col = &#39;lightblue&#39;) . &#51452;&#51032;&#54624; &#51216; . - 그림 자체를 생성 해주는 plot과 같은 명령이 있고, 생성된 그림에 덧붙여서만 그릴 수 있는 lines, points, abline과 같은 기생함수가 있다. . - 기생함수는 단독으로 쓸 수 없다. . lines(x,y) . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(x, y) 2. lines.default(x, y) 3. plot.xy(xy.coords(x, y), type = type, ...) . lines(x,y) ploat(x,y) . &#51452;&#49437; &#51060;&#50857; &#48169;&#48277; . - &#51452;&#49437;&#51008; &#49892;&#54665;&#54616;&#51648; &#50506;&#45716; &#47928;&#51109;&#51060;&#45796;. . a &lt;- 1 a &lt;- a+1 a &lt;- a+1 print(a) . a &lt;- 1 #a &lt;- a+1 a &lt;- a+1 print(a) . - &#50780; &#50416;&#45716;&#44032;? . (1) 코드를 나눠서 테스트 할 때 . (2) 코드에 대한 설명이나 메모를 쓰고 싶을 때 . - &#44284;&#51228; . plot(x,y)와 plot(x,y,type=&#39;l&#39;)을 비교해보기 . plot(x, y) #할당된 점만 표시 . plot(x, y, type = &#39;l&#39;) #할당된 점을 선으로 이어서 표시 .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/09/09/R%EC%9E%85%EB%AC%B8-2%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/09/09/R%EC%9E%85%EB%AC%B8-2%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Sep 9, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "R : 소개",
            "content": "What is R? . R is a language and environment for statistical computing and graphics. | . R은 좋은 계산기이다. | . Problem 1 . Solution I . $I_d = I_0 2^{-0.25d}$ . $ cfrac{I_d}{I_0} = 0.25 = 2^{-2} = 2^{-0.25d}$ . $-2 = -0.25d$ . $d = 8m$ . . 갑 : 음.. 근데 8m 말고 11m일 때랑 7m일 때의 비율도 계산해줘 . 갑 : 아 아니다 그냥 1m부터 40m까지 다 구해줘!! . 을 : ?? (일일이 대입하면 너무 힘든데... 어쩌지?) . . Solution II . $d$를 입력하면 $ cfrac{I_d}{I_0}$가 계산되는 아래와 같은 함수를 만들고 싶다. . $ cfrac{I_d}{I_0}=y=f(d)=2^{-0.25d}$ . f &lt;- function(d){ y=2^(-0.25*d) y } . print(f(8)) . [1] 0.25 . print(f(11)) . [1] 0.1486509 . print(f(7)) . [1] 0.2973018 . for(d in 1:40){ print(f(d)) } . [1] 0.8408964 [1] 0.7071068 [1] 0.5946036 [1] 0.5 [1] 0.4204482 [1] 0.3535534 [1] 0.2973018 [1] 0.25 [1] 0.2102241 [1] 0.1767767 [1] 0.1486509 [1] 0.125 [1] 0.1051121 [1] 0.08838835 [1] 0.07432544 [1] 0.0625 [1] 0.05255603 [1] 0.04419417 [1] 0.03716272 [1] 0.03125 [1] 0.02627801 [1] 0.02209709 [1] 0.01858136 [1] 0.015625 [1] 0.01313901 [1] 0.01104854 [1] 0.009290681 [1] 0.0078125 [1] 0.006569503 [1] 0.005524272 [1] 0.00464534 [1] 0.00390625 [1] 0.003284752 [1] 0.002762136 [1] 0.00232267 [1] 0.001953125 [1] 0.001642376 [1] 0.001381068 [1] 0.001161335 [1] 0.0009765625 . 엄청 편하다.. . Solution III . $y=f(d)$의 그래프를 구하고 싶다. . d &lt;- seq(from = 0, to = 10, by = 0.01) y &lt;- 2^(-0.25*d) plot(d, y, type = &quot;l&quot;, lwd = 5) abline(h = 0.25, col=2, lwd=5, lty = 1) #col = 색, lwd = 굵기, lty = 점선 #h = 수평선, v = 수직선 . 1. 2005 예비평가(나) 12월/평가원26(고3)↩ .",
            "url": "https://stahangryum.github.io/stahangryum/introduction%20to%20r/2021/09/07/R%EC%9E%85%EB%AC%B8-1%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "relUrl": "/introduction%20to%20r/2021/09/07/R%EC%9E%85%EB%AC%B8-1%EC%A3%BC%EC%B0%A8-%ED%95%84%EA%B8%B0.html",
            "date": " • Sep 7, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://stahangryum.github.io/stahangryum/jupyter/2020/02/20/t12est.html",
            "relUrl": "/jupyter/2020/02/20/t12est.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post20": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://stahangryum.github.io/stahangryum/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Contact . Email : stahangryum@gmail.com | .",
          "url": "https://stahangryum.github.io/stahangryum/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://stahangryum.github.io/stahangryum/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}